{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "from __future__ import print_function\n",
    "from __future__ import absolute_import\n",
    "import re\n",
    "import math\n",
    "import warnings\n",
    "import pickle\n",
    "import numpy as np\n",
    "import h5py\n",
    "import argparse\n",
    "from keras import backend as K\n",
    "from keras.models import model_from_json\n",
    "from keras.preprocessing import sequence\n",
    "from keras.models import Sequential\n",
    "from keras.layers.core import Dense, Dropout, Activation\n",
    "from keras.layers.embeddings import Embedding\n",
    "from keras.layers.convolutional import Convolution1D, MaxPooling1D\n",
    "from keras.layers.recurrent import _generate_dropout_mask\n",
    "from keras.layers import Convolution2D, MaxPooling2D, Flatten, TimeDistributed, Bidirectional, normalization\n",
    "from keras.datasets import imdb\n",
    "from keras import activations, initializers, regularizers, constraints, optimizers\n",
    "from keras.engine import InputSpec, Layer\n",
    "from keras.legacy import interfaces\n",
    "from keras.utils import np_utils\n",
    "from sklearn.metrics import  f1_score,precision_score,recall_score, matthews_corrcoef\n",
    "from sklearn import ensemble\n",
    "\n",
    "\n",
    "M = 10  # K-fold cross validation\n",
    "maxLength = 0  # the  sequence maxLength\n",
    "TPsum, FPsum, TNsum, FNsum, ACCsum, F1sum = 0, 0, 0, 0, 0, 0\n",
    "\n",
    "np.random.seed(1337)  # for reproducibility\n",
    "\n",
    "#IndRNN\n",
    "class IndRNNCell(Layer):\n",
    "    \"\"\"Independently Recurrent Neural Networks Cell class.\n",
    "\n",
    "    Derived from the paper [Independently Recurrent Neural Network (IndRNN): Building A Longer and Deeper RNN](https://arxiv.org/abs/1803.04831)\n",
    "    Ref: [Tensorflow implementation](https://github.com/batzner/indrnn)\n",
    "\n",
    "    # Arguments\n",
    "        units: Positive integer, dimensionality of the output space.\n",
    "        recurrent_clip_min: Can be one of None, -1 or float.\n",
    "            If None, clipping of weights will not take place.\n",
    "            If float, exact value will be used as clipping range\n",
    "            If -1, will calculate the clip value for `relu` activation\n",
    "        recurrent_clip_max: Can be one of None or float.\n",
    "            If None, clipping of weights will not take place.\n",
    "            If float, exact value will be used as clipping range\n",
    "            If -1, will calculate the clip value for `relu` activation\n",
    "        activation: Activation function to use\n",
    "            (see [activations](../activations.md)).\n",
    "            If you pass None, no activation is applied\n",
    "            (ie. \"linear\" activation: `a(x) = x`).\n",
    "        use_bias: Boolean, whether the layer uses a bias vector.\n",
    "        kernel_initializer: Initializer for the `kernel` weights matrix,\n",
    "            used for the linear transformation of the inputs\n",
    "            (see [initializers](../initializers.md)).\n",
    "        recurrent_initializer: Initializer for the `recurrent_kernel`\n",
    "            weights matrix, used for the linear transformation of the\n",
    "            recurrent state.\n",
    "            Can be `None` or an available initializer. Defaults to `None`.\n",
    "            If None, defaults to uniform initialization.\n",
    "            If None, and recurrent_clip_min/max is not None, then\n",
    "            it uses those clip values as for uniform initialization.\n",
    "            (see [initializers](../initializers.md)).\n",
    "        bias_initializer: Initializer for the bias vector\n",
    "            (see [initializers](../initializers.md)).\n",
    "        kernel_regularizer: Regularizer function applied to\n",
    "            the `kernel` weights matrix\n",
    "            (see [regularizer](../regularizers.md)).\n",
    "        recurrent_regularizer: Regularizer function applied to\n",
    "            the `recurrent_kernel` weights matrix\n",
    "            (see [regularizer](../regularizers.md)).\n",
    "        bias_regularizer: Regularizer function applied to the bias vector\n",
    "            (see [regularizer](../regularizers.md)).\n",
    "        kernel_constraint: Constraint function applied to\n",
    "            the `kernel` weights matrix\n",
    "            (see [constraints](../constraints.md)).\n",
    "        recurrent_constraint: Constraint function applied to\n",
    "            the `recurrent_kernel` weights matrix\n",
    "            (see [constraints](../constraints.md)).\n",
    "        bias_constraint: Constraint function applied to the bias vector\n",
    "            (see [constraints](../constraints.md)).\n",
    "        dropout: Float between 0 and 1.\n",
    "            Fraction of the units to drop for\n",
    "            the linear transformation of the inputs.\n",
    "        recurrent_dropout: Float between 0 and 1.\n",
    "            Fraction of the units to drop for\n",
    "            the linear transformation of the recurrent state.\n",
    "        implementation: Implementation mode, must be 2.\n",
    "            Mode 1 will structure its operations as a larger number of\n",
    "            smaller dot products and additions, whereas mode 2 will\n",
    "            batch them into fewer, larger operations. These modes will\n",
    "            have different performance profiles on different hardware and\n",
    "            for different applications.\n",
    "    \"\"\"\n",
    "\n",
    "    def __init__(self, units,\n",
    "                 recurrent_clip_min=-1,\n",
    "                 recurrent_clip_max=-1,\n",
    "                 activation='relu',\n",
    "                 use_bias=True,\n",
    "                 kernel_initializer='glorot_uniform',\n",
    "                 recurrent_initializer=None,\n",
    "                 bias_initializer='zeros',\n",
    "                 kernel_regularizer=None,\n",
    "                 recurrent_regularizer=None,\n",
    "                 bias_regularizer=None,\n",
    "                 kernel_constraint=None,\n",
    "                 recurrent_constraint=None,\n",
    "                 bias_constraint=None,\n",
    "                 dropout=0.,\n",
    "                 recurrent_dropout=0.,\n",
    "                 implementation=2,\n",
    "                 **kwargs):\n",
    "        super(IndRNNCell, self).__init__(**kwargs)\n",
    "\n",
    "        if implementation != 2:\n",
    "            warnings.warn(\n",
    "                \"IndRNN only supports implementation 2 for the moment. Defaulting to implementation = 2\")\n",
    "            implementation = 2\n",
    "\n",
    "        if recurrent_clip_min is None or recurrent_clip_max is None:\n",
    "            recurrent_clip_min = None\n",
    "            recurrent_clip_max = None\n",
    "\n",
    "        self.units = units\n",
    "        self.recurrent_clip_min = recurrent_clip_min\n",
    "        self.recurrent_clip_max = recurrent_clip_max\n",
    "        self.activation = activations.get(activation)\n",
    "        self.use_bias = use_bias\n",
    "\n",
    "        self.kernel_initializer = initializers.get(kernel_initializer)\n",
    "        self.recurrent_initializer = initializers.get(recurrent_initializer) \\\n",
    "                                     if recurrent_initializer is not None else None\n",
    "        self.bias_initializer = initializers.get(bias_initializer)\n",
    "\n",
    "        self.kernel_regularizer = regularizers.get(kernel_regularizer)\n",
    "        self.recurrent_regularizer = regularizers.get(recurrent_regularizer)\n",
    "        self.bias_regularizer = regularizers.get(bias_regularizer)\n",
    "\n",
    "        self.kernel_constraint = constraints.get(kernel_constraint)\n",
    "        self.recurrent_constraint = constraints.get(recurrent_constraint)\n",
    "        self.bias_constraint = constraints.get(bias_constraint)\n",
    "\n",
    "        self.dropout = min(1., max(0., dropout))\n",
    "        self.recurrent_dropout = min(1., max(0., recurrent_dropout))\n",
    "        self.implementation = implementation\n",
    "        self.state_size = (self.units,)\n",
    "        self._dropout_mask = None\n",
    "        self._recurrent_masks = None\n",
    "\n",
    "    def build(self, input_shape):\n",
    "        input_dim = input_shape[-1]\n",
    "\n",
    "        if self.recurrent_clip_min == -1 or self.recurrent_clip_max == -1:\n",
    "            self.recurrent_clip_min = 0.0\n",
    "\n",
    "            if hasattr(self, 'timesteps') and self.timesteps is not None:\n",
    "                self.recurrent_clip_max = pow(2.0, 1. / self.timesteps)\n",
    "            else:\n",
    "                warnings.warn(\"IndRNNCell: Number of timesteps could not be determined. \\n\"\n",
    "                              \"Defaulting to max clipping range of 1.0. \\n\"\n",
    "                              \"If this model was trained using a specific timestep during training, \"\n",
    "                              \"inference may be wrong due to this default setting.\\n\"\n",
    "                              \"Please ensure that you use the same number of timesteps during training \"\n",
    "                              \"and evaluation\")\n",
    "                self.recurrent_clip_max = 1.0\n",
    "\n",
    "        self.kernel = self.add_weight(shape=(input_dim, self.units),\n",
    "                                      name='input_kernel',\n",
    "                                      initializer=self.kernel_initializer,\n",
    "                                      regularizer=self.kernel_regularizer,\n",
    "                                      constraint=self.kernel_constraint)\n",
    "\n",
    "        if self.recurrent_initializer is None:\n",
    "            if self.recurrent_clip_min is not None and self.recurrent_clip_max is not None:\n",
    "                initialization_value = min(self.recurrent_clip_max, 1.0)\n",
    "                self.recurrent_initializer = initializers.uniform(-initialization_value,\n",
    "                                                                  initialization_value)\n",
    "            else:\n",
    "                self.recurrent_initializer = initializers.uniform(-1.0, 1.0)\n",
    "\n",
    "        self.recurrent_kernel = self.add_weight(shape=(self.units,),\n",
    "                                                name='recurrent_kernel',\n",
    "                                                initializer=self.recurrent_initializer,\n",
    "                                                regularizer=self.recurrent_regularizer,\n",
    "                                                constraint=self.recurrent_constraint)\n",
    "\n",
    "        if self.recurrent_clip_min is not None and self.recurrent_clip_max is not None:\n",
    "            if abs(self.recurrent_clip_min):\n",
    "                abs_recurrent_kernel = K.abs(self.recurrent_kernel)\n",
    "                min_recurrent_kernel = K.maximum(abs_recurrent_kernel, abs(self.recurrent_clip_min))\n",
    "                self.recurrent_kernel = K.sign(self.recurrent_kernel) * min_recurrent_kernel\n",
    "\n",
    "            self.recurrent_kernel = K.clip(self.recurrent_kernel,\n",
    "                                           self.recurrent_clip_min,\n",
    "                                           self.recurrent_clip_max)\n",
    "\n",
    "        if self.use_bias:\n",
    "            bias_initializer = self.bias_initializer\n",
    "\n",
    "            self.bias = self.add_weight(shape=(self.units,),\n",
    "                                        name='bias',\n",
    "                                        initializer=bias_initializer,\n",
    "                                        regularizer=self.bias_regularizer,\n",
    "                                        constraint=self.bias_constraint)\n",
    "        else:\n",
    "            self.bias = None\n",
    "\n",
    "        self.built = True\n",
    "\n",
    "    def call(self, inputs, states, training=None):\n",
    "        if 0 < self.dropout < 1 and self._dropout_mask is None:\n",
    "            self._dropout_mask = _generate_dropout_mask(\n",
    "                K.ones_like(inputs),\n",
    "                self.dropout,\n",
    "                training=training,\n",
    "                count=1)\n",
    "        if (0 < self.recurrent_dropout < 1 and\n",
    "                self._recurrent_masks is None):\n",
    "            _recurrent_mask = _generate_dropout_mask(\n",
    "                K.ones_like(states[0]),\n",
    "                self.recurrent_dropout,\n",
    "                training=training,\n",
    "                count=1)\n",
    "            self._recurrent_masks = _recurrent_mask\n",
    "\n",
    "        # dropout matrices for input units\n",
    "        dp_mask = self._dropout_mask\n",
    "        # dropout matrices for recurrent units\n",
    "        rec_dp_masks = self._recurrent_masks\n",
    "\n",
    "        h_tm1 = states[0]  # previous state\n",
    "\n",
    "        if 0. < self.dropout < 1.:\n",
    "            inputs *= dp_mask[0]\n",
    "\n",
    "        if 0. < self.recurrent_dropout < 1.:\n",
    "            h_tm1 *= rec_dp_masks[0]\n",
    "\n",
    "        h = K.dot(inputs, self.kernel)\n",
    "        h = h + (h_tm1 * self.recurrent_kernel)\n",
    "\n",
    "        if self.use_bias:\n",
    "            h = K.bias_add(h, self.bias)\n",
    "\n",
    "        h = self.activation(h)\n",
    "\n",
    "        if 0 < self.dropout + self.recurrent_dropout:\n",
    "            if training is None:\n",
    "                h._uses_learning_phase = True\n",
    "        return h, [h]\n",
    "\n",
    "    def get_config(self):\n",
    "        config = {'units': self.units,\n",
    "                  'recurrent_clip_min': self.recurrent_clip_min,\n",
    "                  'recurrent_clip_max': self.recurrent_clip_max,\n",
    "                  'activation': activations.serialize(self.activation),\n",
    "                  'use_bias': self.use_bias,\n",
    "                  'kernel_initializer': initializers.serialize(self.kernel_initializer),\n",
    "                  'recurrent_initializer': initializers.serialize(self.recurrent_initializer),\n",
    "                  'bias_initializer': initializers.serialize(self.bias_initializer),\n",
    "                  'kernel_regularizer': regularizers.serialize(self.kernel_regularizer),\n",
    "                  'recurrent_regularizer': regularizers.serialize(self.recurrent_regularizer),\n",
    "                  'bias_regularizer': regularizers.serialize(self.bias_regularizer),\n",
    "                  'kernel_constraint': constraints.serialize(self.kernel_constraint),\n",
    "                  'recurrent_constraint': constraints.serialize(self.recurrent_constraint),\n",
    "                  'bias_constraint': constraints.serialize(self.bias_constraint),\n",
    "                  'dropout': self.dropout,\n",
    "                  'recurrent_dropout': self.recurrent_dropout,\n",
    "                  'implementation': self.implementation}\n",
    "        base_config = super(IndRNNCell, self).get_config()\n",
    "        return dict(list(base_config.items()) + list(config.items()))\n",
    "\n",
    "\n",
    "class IndRNN(RNN):\n",
    "    \"\"\"Independently Recurrent Neural Networks Cell class.\n",
    "\n",
    "    Derived from the paper [Independently Recurrent Neural Network (IndRNN): Building A Longer and Deeper RNN](https://arxiv.org/abs/1803.04831)\n",
    "    Ref: [Tensorflow implementation](https://github.com/batzner/indrnn)\n",
    "\n",
    "    # Arguments\n",
    "        units: Positive integer, dimensionality of the output space.\n",
    "        recurrent_clip_min: Can be one of None, -1 or float.\n",
    "            If None, clipping of weights will not take place.\n",
    "            If float, exact value will be used as clipping range\n",
    "            If -1, computes the default clipping range for Relu activations\n",
    "        recurrent_clip_max: Can be one of None, -1 or float.\n",
    "            If None, clipping of weights will not take place.\n",
    "            If float, exact value will be used as clipping range\n",
    "            If -1, computes the default clipping range for Relu activations\n",
    "        activation: Activation function to use\n",
    "            (see [activations](../activations.md)).\n",
    "            If you pass None, no activation is applied\n",
    "            (ie. \"linear\" activation: `a(x) = x`).\n",
    "        use_bias: Boolean, whether the layer uses a bias vector.\n",
    "        kernel_initializer: Initializer for the `kernel` weights matrix,\n",
    "            used for the linear transformation of the inputs.\n",
    "            (see [initializers](../initializers.md)).\n",
    "        recurrent_initializer: Initializer for the `recurrent_kernel`\n",
    "            weights matrix,\n",
    "            used for the linear transformation of the recurrent state.\n",
    "            (see [initializers](../initializers.md)).\n",
    "        bias_initializer: Initializer for the bias vector\n",
    "            (see [initializers](../initializers.md)).\n",
    "        unit_forget_bias: Boolean.\n",
    "            If True, add 1 to the bias of the forget gate at initialization.\n",
    "            Setting it to true will also force `bias_initializer=\"zeros\"`.\n",
    "            This is recommended in [Jozefowicz et al.](http://www.jmlr.org/proceedings/papers/v37/jozefowicz15.pdf)\n",
    "        kernel_regularizer: Regularizer function applied to\n",
    "            the `kernel` weights matrix\n",
    "            (see [regularizer](../regularizers.md)).\n",
    "        recurrent_regularizer: Regularizer function applied to\n",
    "            the `recurrent_kernel` weights matrix\n",
    "            (see [regularizer](../regularizers.md)).\n",
    "        bias_regularizer: Regularizer function applied to the bias vector\n",
    "            (see [regularizer](../regularizers.md)).\n",
    "        activity_regularizer: Regularizer function applied to\n",
    "            the output of the layer (its \"activation\").\n",
    "            (see [regularizer](../regularizers.md)).\n",
    "        kernel_constraint: Constraint function applied to\n",
    "            the `kernel` weights matrix\n",
    "            (see [constraints](../constraints.md)).\n",
    "        recurrent_constraint: Constraint function applied to\n",
    "            the `recurrent_kernel` weights matrix\n",
    "            (see [constraints](../constraints.md)).\n",
    "        bias_constraint: Constraint function applied to the bias vector\n",
    "            (see [constraints](../constraints.md)).\n",
    "        dropout: Float between 0 and 1.\n",
    "            Fraction of the units to drop for\n",
    "            the linear transformation of the inputs.\n",
    "        recurrent_dropout: Float between 0 and 1.\n",
    "            Fraction of the units to drop for\n",
    "            the linear transformation of the recurrent state.\n",
    "        implementation: Implementation mode, either 1 or 2.\n",
    "            Mode 1 will structure its operations as a larger number of\n",
    "            smaller dot products and additions, whereas mode 2 will\n",
    "            batch them into fewer, larger operations. These modes will\n",
    "            have different performance profiles on different hardware and\n",
    "            for different applications.\n",
    "        return_sequences: Boolean. Whether to return the last output.\n",
    "            in the output sequence, or the full sequence.\n",
    "        return_state: Boolean. Whether to return the last state\n",
    "            in addition to the output.\n",
    "        go_backwards: Boolean (default False).\n",
    "            If True, process the input sequence backwards and return the\n",
    "            reversed sequence.\n",
    "        stateful: Boolean (default False). If True, the last state\n",
    "            for each sample at index i in a batch will be used as initial\n",
    "            state for the sample of index i in the following batch.\n",
    "        unroll: Boolean (default False).\n",
    "            If True, the network will be unrolled,\n",
    "            else a symbolic loop will be used.\n",
    "            Unrolling can speed-up a RNN,\n",
    "            although it tends to be more memory-intensive.\n",
    "            Unrolling is only suitable for short sequences.\n",
    "\n",
    "    # References\n",
    "        - [Learning to forget: Continual prediction with NestedLSTM](http://www.mitpressjournals.org/doi/pdf/10.1162/089976600300015015)\n",
    "        - [Supervised sequence labeling with recurrent neural networks](http://www.cs.toronto.edu/~graves/preprint.pdf)\n",
    "        - [A Theoretically Grounded Application of Dropout in Recurrent Neural Networks](http://arxiv.org/abs/1512.05287)\n",
    "        - [Independently Recurrent Neural Network (IndRNN): Building A Longer and Deeper RNN](https://arxiv.org/abs/1803.04831)\n",
    "    \"\"\"\n",
    "\n",
    "    @interfaces.legacy_recurrent_support\n",
    "    def __init__(self, units,\n",
    "                 recurrent_clip_min=-1,\n",
    "                 recurrent_clip_max=-1,\n",
    "                 activation='relu',\n",
    "                 use_bias=True,\n",
    "                 kernel_initializer='glorot_uniform',\n",
    "                 recurrent_initializer=None,\n",
    "                 bias_initializer='zeros',\n",
    "                 kernel_regularizer=None,\n",
    "                 recurrent_regularizer=None,\n",
    "                 bias_regularizer=None,\n",
    "                 activity_regularizer=None,\n",
    "                 kernel_constraint=None,\n",
    "                 recurrent_constraint=None,\n",
    "                 bias_constraint=None,\n",
    "                 dropout=0.,\n",
    "                 recurrent_dropout=0.,\n",
    "                 implementation=2,\n",
    "                 return_sequences=False,\n",
    "                 return_state=False,\n",
    "                 go_backwards=False,\n",
    "                 stateful=False,\n",
    "                 unroll=False,\n",
    "                 **kwargs):\n",
    "        if implementation == 0:\n",
    "            warnings.warn('`implementation=0` has been deprecated, '\n",
    "                          'and now defaults to `implementation=2`.'\n",
    "                          'Please update your layer call.')\n",
    "        if K.backend() == 'theano':\n",
    "            warnings.warn(\n",
    "                'RNN dropout is no longer supported with the Theano backend '\n",
    "                'due to technical limitations. '\n",
    "                'You can either set `dropout` and `recurrent_dropout` to 0, '\n",
    "                'or use the TensorFlow backend.')\n",
    "            dropout = 0.\n",
    "            recurrent_dropout = 0.\n",
    "\n",
    "        cell = IndRNNCell(units,\n",
    "                          recurrent_clip_min=recurrent_clip_min,\n",
    "                          recurrent_clip_max=recurrent_clip_max,\n",
    "                          activation=activation,\n",
    "                          use_bias=use_bias,\n",
    "                          kernel_initializer=kernel_initializer,\n",
    "                          recurrent_initializer=recurrent_initializer,\n",
    "                          bias_initializer=bias_initializer,\n",
    "                          kernel_regularizer=kernel_regularizer,\n",
    "                          recurrent_regularizer=recurrent_regularizer,\n",
    "                          bias_regularizer=bias_regularizer,\n",
    "                          kernel_constraint=kernel_constraint,\n",
    "                          recurrent_constraint=recurrent_constraint,\n",
    "                          bias_constraint=bias_constraint,\n",
    "                          dropout=dropout,\n",
    "                          recurrent_dropout=recurrent_dropout,\n",
    "                          implementation=implementation)\n",
    "        super(IndRNN, self).__init__(cell,\n",
    "                                     return_sequences=return_sequences,\n",
    "                                     return_state=return_state,\n",
    "                                     go_backwards=go_backwards,\n",
    "                                     stateful=stateful,\n",
    "                                     unroll=unroll,\n",
    "                                     **kwargs)\n",
    "        self.activity_regularizer = regularizers.get(activity_regularizer)\n",
    "\n",
    "    def build(self, input_shape):\n",
    "        timesteps = input_shape[1]\n",
    "\n",
    "        if timesteps is None:\n",
    "            warnings.warn(\"Number of timesteps was not provided. If this model is being used for training purposes, \\n\"\n",
    "                          \"it is recommended to provide a finite number of timesteps when defining the input shape, \\n\"\n",
    "                          \"so as to initialize the weights of the recurrent kernel properly and avoid exploding gradients.\")\n",
    "\n",
    "        self.cell.timesteps = timesteps\n",
    "\n",
    "        super(IndRNN, self).build(input_shape)\n",
    "\n",
    "    def call(self, inputs, mask=None, training=None, initial_state=None, constants=None):\n",
    "        self.cell._dropout_mask = None\n",
    "        self.cell._recurrent_masks = None\n",
    "        return super(IndRNN, self).call(inputs,\n",
    "                                        mask=mask,\n",
    "                                        training=training,\n",
    "                                        initial_state=initial_state,\n",
    "                                        constants=constants)\n",
    "\n",
    "    @property\n",
    "    def units(self):\n",
    "        return self.cell.units\n",
    "\n",
    "    @property\n",
    "    def recurrent_clip_min(self):\n",
    "        return self.cell.recurrent_clip_min\n",
    "\n",
    "    @property\n",
    "    def recurrent_clip_max(self):\n",
    "        return self.cell.recurrent_clip_max\n",
    "\n",
    "    @property\n",
    "    def activation(self):\n",
    "        return self.cell.activation\n",
    "\n",
    "    @property\n",
    "    def use_bias(self):\n",
    "        return self.cell.use_bias\n",
    "\n",
    "    @property\n",
    "    def kernel_initializer(self):\n",
    "        return self.cell.kernel_initializer\n",
    "\n",
    "    @property\n",
    "    def recurrent_initializer(self):\n",
    "        return self.cell.recurrent_initializer\n",
    "\n",
    "    @property\n",
    "    def bias_initializer(self):\n",
    "        return self.cell.bias_initializer\n",
    "\n",
    "    @property\n",
    "    def kernel_regularizer(self):\n",
    "        return self.cell.kernel_regularizer\n",
    "\n",
    "    @property\n",
    "    def recurrent_regularizer(self):\n",
    "        return self.cell.recurrent_regularizer\n",
    "\n",
    "    @property\n",
    "    def bias_regularizer(self):\n",
    "        return self.cell.bias_regularizer\n",
    "\n",
    "    @property\n",
    "    def kernel_constraint(self):\n",
    "        return self.cell.kernel_constraint\n",
    "\n",
    "    @property\n",
    "    def recurrent_constraint(self):\n",
    "        return self.cell.recurrent_constraint\n",
    "\n",
    "    @property\n",
    "    def bias_constraint(self):\n",
    "        return self.cell.bias_constraint\n",
    "\n",
    "    @property\n",
    "    def dropout(self):\n",
    "        return self.cell.dropout\n",
    "\n",
    "    @property\n",
    "    def recurrent_dropout(self):\n",
    "        return self.cell.recurrent_dropout\n",
    "\n",
    "    @property\n",
    "    def implementation(self):\n",
    "        return self.cell.implementation\n",
    "\n",
    "    def get_config(self):\n",
    "        config = {'units': self.units,\n",
    "                  'recurrent_clip_min': self.recurrent_clip_min,\n",
    "                  'recurrent_clip_max': self.recurrent_clip_max,\n",
    "                  'activation': activations.serialize(self.activation),\n",
    "                  'use_bias': self.use_bias,\n",
    "                  'kernel_initializer': initializers.serialize(self.kernel_initializer),\n",
    "                  'recurrent_initializer': initializers.serialize(self.recurrent_initializer),\n",
    "                  'bias_initializer': initializers.serialize(self.bias_initializer),\n",
    "                  'kernel_regularizer': regularizers.serialize(self.kernel_regularizer),\n",
    "                  'recurrent_regularizer': regularizers.serialize(self.recurrent_regularizer),\n",
    "                  'bias_regularizer': regularizers.serialize(self.bias_regularizer),\n",
    "                  'activity_regularizer': regularizers.serialize(self.activity_regularizer),\n",
    "                  'kernel_constraint': constraints.serialize(self.kernel_constraint),\n",
    "                  'recurrent_constraint': constraints.serialize(self.recurrent_constraint),\n",
    "                  'bias_constraint': constraints.serialize(self.bias_constraint),\n",
    "                  'dropout': self.dropout,\n",
    "                  'recurrent_dropout': self.recurrent_dropout,\n",
    "                  'implementation': self.implementation}\n",
    "        base_config = super(IndRNN, self).get_config()\n",
    "        del base_config['cell']\n",
    "        return dict(list(base_config.items()) + list(config.items()))\n",
    "\n",
    "    @classmethod\n",
    "    def from_config(cls, config):\n",
    "        if 'implementation' in config and config['implementation'] == 0:\n",
    "            config['implementation'] = 2\n",
    "        return cls(**config)\n",
    "\n",
    "\n",
    "# Load data\n",
    "sequencepath = 'sequence.fasta' # raw sequence information\n",
    "featurepath = 'features.fasta' # feature information\n",
    "\n",
    "listsequence = open(sequencepath, 'r').readlines()\n",
    "listfeature = open(featurepath,'r').readlines()\n",
    "\n",
    "# Get the maximum maxLength of the sequence\n",
    "for linemaxLength in listsequence:\n",
    "    miRNAname, lncRNAname, sequence, label = linemaxLength.split(',')\n",
    "    if len(sequence) > maxLength:\n",
    "        maxLength = len(sequence)\n",
    "\n",
    "# Initialize evaluation criteria\n",
    "\n",
    "# one-hot encoding\n",
    "def onehot(list, maxLength):\n",
    "    onehotsequence = []\n",
    "    onehotlabel = []\n",
    "    ATCG = 'ATCG'  # alphabet\n",
    "    char_to_int = dict((c, j) for j, c in enumerate(ATCG))  \n",
    "\n",
    "    for line in list:\n",
    "        miRNAname, lncRNAname, sequence, label = line.split(',')\n",
    "        sequence = sequence.upper()\n",
    "        sequence = sequence.replace('U', 'T')\n",
    "\n",
    "        # integer encoding\n",
    "        integer_encoded = [char_to_int[char] for char in sequence]\n",
    "\n",
    "        # one-hot encoding\n",
    "        hot_encoded = []\n",
    "\n",
    "        # encoding\n",
    "        for value in integer_encoded:\n",
    "            letter = [0 for _ in range(len(ATCG))]\n",
    "            letter[value] = 1\n",
    "            hot_encoded.append(letter)\n",
    "        # zero-padding\n",
    "        if len(hot_encoded) < maxLength:\n",
    "            zero = maxLength - len(hot_encoded)\n",
    "            letter = [0 for _ in range(len(ATCG))]\n",
    "            for i in range(zero):\n",
    "                hot_encoded.append(letter)\n",
    "\n",
    "        hot_encoded_array = np.array(hot_encoded).reshape(-1, 4)\n",
    "\n",
    "        onehotsequence.append(hot_encoded_array)\n",
    "\n",
    "        onehotlabel.append(label.strip('\\n'))\n",
    "\n",
    "    X = np.array(onehotsequence).reshape(-1, maxLength, 4, 1)\n",
    "    X = X.astype('float32')\n",
    "    Y = np.array(onehotlabel).astype('int').reshape(-1, 1)\n",
    "    Y = np_utils.to_categorical(Y, num_classes=2)\n",
    "\n",
    "    return X, Y\n",
    "\n",
    "# create deep learning data\n",
    "def createdatadeeplearning(X, Y, iteration, M):\n",
    "\n",
    "    # separate the data\n",
    "    totalpartX = len(X)\n",
    "    partX = int(totalpartX / M)\n",
    "    totalpartY = len(Y)\n",
    "    partY = int(totalpartY / M)\n",
    "\n",
    "    partXstart = iteration * partX\n",
    "    partXend = partXstart + partX\n",
    "\n",
    "    partYstart = iteration * partY\n",
    "    partYend = partYstart + partY\n",
    "\n",
    "    traindataP = np.array(X[0 : partXstart])\n",
    "    traindataL = np.array(X[partXend : totalpartX])\n",
    "    traindata = np.concatenate((traindataP, traindataL))\n",
    "    testdata = np.array(X[partXstart : partXend])\n",
    "\n",
    "    trainlabelP = np.array(Y[0 : partYstart])\n",
    "    trainlabelL = np.array(Y[partYend : totalpartY])\n",
    "    trainlabel = np.concatenate((trainlabelP, trainlabelL))\n",
    "    testlabel = np.array(Y[partYstart : partYend])\n",
    "\n",
    "    return traindata, trainlabel, testdata, testlabel\n",
    "\n",
    "# create machine learning data\n",
    "def createdatamachinelearning(data, iteration, M):\n",
    "\n",
    "    # separate the data\n",
    "    totalpartdata = len(data)\n",
    "    partdata = int(totalpartdata / M)\n",
    "    partdatastart = iteration * partdata\n",
    "    partdataend = partdatastart + partdata\n",
    "    traindataP = data[0 : partdatastart]\n",
    "    traindataL = data[partdataend : totalpartdata]\n",
    "    traindata = traindataP + traindataL\n",
    "    testdata = data[partdatastart : partdataend]\n",
    "\n",
    "    # separate the label\n",
    "    rowtraindata = len(traindata)\n",
    "    columntraindata = len(traindata[0].split()) - 1\n",
    "    rowtestdata = len(testdata)\n",
    "    columntestdata = len(testdata[0].split()) - 1\n",
    "\n",
    "    # get the training data and label\n",
    "    trainfeature = [([0] * columntraindata) for p in range(rowtraindata)]\n",
    "    trainlabel = [([0] * 1) for p in range(rowtraindata)]\n",
    "    for linetraindata in traindata:\n",
    "        setraindata = re.split(r'\\s', linetraindata)\n",
    "        indextraindata = traindata.index(linetraindata)\n",
    "        for itraindata in range(len(setraindata) - 1):\n",
    "            if itraindata < len(setraindata) - 2:\n",
    "                trainfeature[indextraindata][itraindata] = float(setraindata[itraindata])\n",
    "            else:\n",
    "                trainlabel[indextraindata][0] = float(setraindata[itraindata])\n",
    "\n",
    "    # get the test data and label\n",
    "    testfeature = [([0] * columntestdata) for p in range(rowtestdata)]\n",
    "    testlabel = [([0] * 1) for p in range(rowtestdata)]\n",
    "    for linetestdata in testdata:\n",
    "        setestdata = re.split(r'\\s', linetestdata)\n",
    "        indextestdata = testdata.index(linetestdata)\n",
    "        for itestdata in range(0, len(setestdata) - 1):\n",
    "            if itestdata < len(setestdata) - 2:\n",
    "                testfeature[indextestdata][itestdata] = float(setestdata[itestdata])\n",
    "            else:\n",
    "                testlabel[indextestdata][0] = float(setestdata[itestdata])\n",
    "\n",
    "    return trainfeature, trainlabel, testfeature, testlabel\n",
    "\n",
    "\n",
    "def CIRNN(traindata, trainlabel, testdata, testlabel, maxLength):\n",
    "\n",
    "    # Model\n",
    "    model = Sequential()\n",
    "\n",
    "    # Convolution layer\n",
    "    model.add(Convolution2D(batch_input_shape=(None, maxLength, 4, 1), filters=32, kernel_size=4, strides=1, padding='same', data_format='channels_last'))\n",
    "\n",
    "    # Batch Normalization layer\n",
    "    normalization.BatchNormalization(axis=1, momentum=0.99, epsilon=0.001, center=True, scale=True, beta_initializer='zeros',\n",
    "                                     gamma_initializer='ones', moving_mean_initializer='zeros', moving_variance_initializer='ones',\n",
    "                                     beta_regularizer=None, gamma_regularizer=None, beta_constraint=None, gamma_constraint=None)\n",
    "\n",
    "    # Activation function\n",
    "    model.add(Activation('relu'))\n",
    "    \n",
    "\n",
    "    # MaxPooling layer\n",
    "    model.add(MaxPooling2D(pool_size=4, strides=4, padding='same', data_format='channels_last'))\n",
    "    model.add(Dropout(0.5))\n",
    "    # Convolution layer\n",
    "    model.add(Convolution2D(64, 4, strides=1, padding='same', data_format='channels_first'))\n",
    "    \n",
    "\n",
    "    # Batch Normalization layer\n",
    "    normalization.BatchNormalization(axis=1, momentum=0.99, epsilon=0.001, center=True, scale=True, beta_initializer='zeros',\n",
    "                                     gamma_initializer='ones', moving_mean_initializer='zeros', moving_variance_initializer='ones',\n",
    "                                     beta_regularizer=None, gamma_regularizer=None, beta_constraint=None, gamma_constraint=None)\n",
    "\n",
    "    # Activation function\n",
    "    model.add(Activation('relu'))\n",
    "\n",
    "    # MaxPooling layer\n",
    "    model.add(MaxPooling2D(4, 4, 'same', data_format='channels_last'))\n",
    "    model.add(Dropout(0.3))\n",
    "    # Flatten layer\n",
    "    model.add(TimeDistributed(Flatten()))\n",
    "    \n",
    "    \n",
    "    #IndRNN\n",
    "    model.add(IndRNN(128, recurrent_clip_min=-1, recurrent_clip_max=-1, dropout=0.0, recurrent_dropout=0.0,\n",
    "                 return_sequences=True))\n",
    "    model.add(IndRNN(128, recurrent_clip_min=-1, recurrent_clip_max=-1, dropout=0.0, recurrent_dropout=0.0,\n",
    "                 return_sequences=False))\n",
    "\n",
    "\n",
    "    # Drouout layer\n",
    "    #model.add(Dropout(0.5))\n",
    "\n",
    "    # fully-connected layer\n",
    "    model.add(Dense(2))\n",
    "    model.add(Activation('softmax'))\n",
    "\n",
    "    # optimizer\n",
    "    sgd = optimizers.SGD(lr=0.005, decay=1e-6, momentum=0.9, nesterov=True)\n",
    "    model.compile(optimizer=sgd, loss='categorical_crossentropy', metrics=['accuracy'])\n",
    "\n",
    "    # training\n",
    "    print('Training*************************************************')\n",
    "    model.fit(traindata, trainlabel, epochs=10, batch_size=64, verbose=1)\n",
    "\n",
    "    # test\n",
    "    print('\\nTesting************************************************')\n",
    "    loss, accuracy = model.evaluate(testdata, testlabel)\n",
    "\n",
    "    # get the confidence probability\n",
    "    resultslabel = model.predict(testdata)\n",
    "\n",
    "    return resultslabel\n",
    "\n",
    "# RF model\n",
    "def RF(trainfeature, trainlabel, testfeature):\n",
    "\n",
    "    RFStruct = ensemble.RandomForestClassifier()\n",
    "    RFStruct.fit(trainfeature, trainlabel) # training\n",
    "    group = RFStruct.predict(testfeature) # test\n",
    "    score = RFStruct.predict_proba(testfeature) # get the confidence probability\n",
    "\n",
    "    return group, score\n",
    "\n",
    "# calculate the results of deep learning model\n",
    "def comparisondeeplearning(testlabel, resultslabel):\n",
    "\n",
    "    # initialization\n",
    "    TP, FP, TN, FN = 0, 0, 0, 0\n",
    "\n",
    "    # formatting\n",
    "    for row1 in range(resultslabel.shape[0]):\n",
    "        for column1 in range(resultslabel.shape[1]):\n",
    "            if resultslabel[row1][column1] < 0.5:\n",
    "                resultslabel[row1][column1] = 0\n",
    "            else:\n",
    "                resultslabel[row1][column1] = 1\n",
    "\n",
    "    # TP, FP, TN, FN\n",
    "    for row2 in range(testlabel.shape[0]):\n",
    "        # TP\n",
    "        if testlabel[row2][0] == 0 and testlabel[row2][1] == 1 and testlabel[row2][0] == resultslabel[row2][0] and testlabel[row2][1] == resultslabel[row2][1]:\n",
    "            TP = TP + 1\n",
    "        # FP\n",
    "        if testlabel[row2][0] == 1 and testlabel[row2][1] == 0 and testlabel[row2][0] != resultslabel[row2][0] and testlabel[row2][1] != resultslabel[row2][1]:\n",
    "            FP = FP + 1\n",
    "        # TN\n",
    "        if testlabel[row2][0] == 1 and testlabel[row2][1] == 0 and testlabel[row2][0] == resultslabel[row2][0] and testlabel[row2][1] == resultslabel[row2][1]:\n",
    "            TN = TN + 1\n",
    "        # FN\n",
    "        if testlabel[row2][0] == 0 and testlabel[row2][1] == 1 and testlabel[row2][0] != resultslabel[row2][0] and testlabel[row2][1] != resultslabel[row2][1]:\n",
    "            FN = FN + 1\n",
    "\n",
    "   \n",
    "    # ACC：accuracy\n",
    "    if TP + TN + FP + FN != 0:\n",
    "        ACC = (TP + TN) / (TP + TN + FP + FN)\n",
    "    else:\n",
    "        ACC = 999999\n",
    "\n",
    "    # F1 score：is the harmonic mean of precision and sensitivity\n",
    "    if TP + FP + FN != 0:\n",
    "        F1 = (2 * TP) / (2 * TP + FP + FN)\n",
    "    else:\n",
    "        F1 = 999999\n",
    "\n",
    "\n",
    "\n",
    "    return TP, FP, TN, FN, ACC, F1\n",
    "\n",
    "# calculate the results of machine learning model\n",
    "def comparisonmachinelearning(testlabel, group):\n",
    "\n",
    "    TP = 0\n",
    "    FP = 0\n",
    "    TN = 0\n",
    "    FN = 0\n",
    "\n",
    "    for row in range(len(testlabel)):\n",
    "        # TP\n",
    "        if testlabel[row][0] == 1 and testlabel[row][0] == group[row]:\n",
    "            TP = TP + 1\n",
    "        # FP\n",
    "        if testlabel[row][0] == 0 and testlabel[row][0] != group[row]:\n",
    "            FP = FP + 1\n",
    "        # TN\n",
    "        if testlabel[row][0] == 0 and testlabel[row][0] == group[row]:\n",
    "            TN = TN + 1\n",
    "        # FN\n",
    "        if testlabel[row][0] == 1 and testlabel[row][0] != group[row]:\n",
    "            FN = FN + 1\n",
    "\n",
    "    \n",
    "    # ACC：accuracy\n",
    "    if TP + TN + FP + FN != 0:\n",
    "        ACC = (TP + TN) / (TP + TN + FP + FN)\n",
    "    else:\n",
    "        ACC = 999999\n",
    "\n",
    "    # F1 score：is the harmonic mean of precision and sensitivity\n",
    "    if TP + FP + FN != 0:\n",
    "        F1 = (2 * TP) / (2 * TP + FP + FN)\n",
    "    else:\n",
    "        F1 = 999999\n",
    "\n",
    "\n",
    "    return TP, FP, TN, FN, ACC, F1\n",
    "\n",
    "# encoding\n",
    "X, Y = onehot(listsequence, maxLength)\n",
    "\n",
    "# cross validation\n",
    "for iteration in range(M):\n",
    "\n",
    "    # deep learning data\n",
    "    traindata, trainlabeldl, testdata, testlabeldl = createdatadeeplearning(X, Y, iteration, M)\n",
    "\n",
    "    # CIRNN model\n",
    "    resultslabel = CIRNN(traindata, trainlabeldl, testdata, testlabeldl, maxLength)\n",
    "\n",
    "    # machine learning data\n",
    "    trainfeature, trainlabelml, testfeature, testlabelml = createdatamachinelearning(listfeature, iteration, M)\n",
    "\n",
    "    # RF\n",
    "    RFgroup, RFscore = RF(trainfeature, trainlabelml, testfeature)\n",
    "\n",
    "    # weighted average\n",
    "    for rowfuz in range(resultslabel.shape[0]):\n",
    "        \n",
    "        resultslabel[rowfuz][0] = resultslabel[rowfuz][0] * 0.5 + RFscore[rowfuz][0] * 0.5\n",
    "        resultslabel[rowfuz][1] = resultslabel[rowfuz][1] * 0.5 + RFscore[rowfuz][1] * 0.5\n",
    "\n",
    "\n",
    "    # obtain the results\n",
    "    TP, FP, TN, FN, ACC, F1 = comparisondeeplearning(testlabeldl, resultslabel)\n",
    "\n",
    "    # print the results of each fold\n",
    "    print('The', iteration + 1, 'fold')\n",
    "    print('TP:', TP, 'FP:', FP, 'TN:', TN, 'FN:', FN)\n",
    "    print('ACC:', ACC, 'F1:', F1)\n",
    "\n",
    "    # add the results\n",
    "    TPsum += TP\n",
    "    FPsum += FP\n",
    "    TNsum += TN\n",
    "    FNsum += FN\n",
    "    ACCsum += ACC\n",
    "    F1sum += F1\n",
    "\n",
    "\n",
    "\n",
    "# obtain the average results\n",
    "TPaverage, FPaverage, TNaverage, FNaverage, ACCaverage, F1average  = TPsum / M, FPsum / M, TNsum / M, FNsum / M, ACCsum / M, F1sum / M\n",
    "\n",
    "# print the results\n",
    "print('\\ntest average TP: ', TPaverage)\n",
    "print('\\ntest average FP: ', FPaverage)\n",
    "print('\\ntest average TN: ', TNaverage)\n",
    "print('\\ntest average FN: ', FNaverage)\n",
    "print('\\ntest average ACC: ', ACCaverage)\n",
    "print('\\ntest average F1: ', F1average)\n",
    "\n",
    "\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
